<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({
 tex2jax: {
 inlineMath: [['$', '$'] ],
 displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
 }
 });
</script>

# 修正履歴
- 2024/02/12 新規作成

# このページについて
このページは**レーベンシュタイン距離**の理論、プログラムについて私なりに説明しています。

# 理論
レーベンシュタイン距離は２つの文字列の間の距離を与えるものだと認識しています。
ある文字列 $a$ を以下の操作のみを使って別の文字列 $b$ へと書き換える時、それらの一つ一つの手順を数えます。

- 文字の挿入（$I$）
- 文字の削除（$D$）
- 文字の置換（$R$）

挿入の例を見ましょう。$x="stein"$, $y="steain"$ という２つの文字列を考えます。この場合、$"a"$ という文字を文字列 $x$ の文字 $"e"$ と $"i"$ の間に挿入すると文字列 $y$ を得ます。
<div style="text-align: center;">
st<b>ei</b>n => st<b>eai</b>n
</div>

削除の例を見ましょう。これは挿入の例の操作の方向を逆にすれば得られます。つまり２つの文字列 $x="steain"$, $y="stein"$ を考える時、$x$ の文字"e" と "i" の間の文字 "a" を削除します。
<div style="text-align: center;">
st<b>eai</b>n => st<b>ei</b>n
</div>

置換の例を見ましょう。２つの文字列 $x="stein"$, $y="stain"$ を考えます。この場合、文字 $"e"$ が $"a"$ への置換の対象となります。
<div style="text-align: center;">
st<b>e</b>in => st<b>a</b>in
</div>

挿入と置換が混在している例を見ましょう。文字列 $x="bnb"$ から $y="anana"$ へ書き換える時、いくつかの操作の経路が存在します。例えば
<div style="text-align: center;">
<b>b</b>nb =>r an<b>b</b> =>r ana =>i ana<b>n</b> =>i anan<b>a</b>
</div>
<div style="text-align: center;">
bnb =>i bnb<b>n</b> =>i <b>b</b>nbn<b>b</b> =>r an<b>b</b>nb =>r anan<b>b</b> =>r anana
</div>
ただし、=>i は挿入を表し =>r は置換を表します。挿入の場合は書き換え後に挿入した文字を太文字で表し、置換の場合は書き換え前に置換する文字を太文字で表しています。

一方の数は$4$、他方の数は$5$であり数が異なります。

いくつかの操作の経路の中で操作の数が最小であるものが**レーベンシュタイン距離**を与えます。

## 数学的性質

以下、レーベンシュタイン距離の計算アルゴリズムのための数学的性質を見ていきましょう。端的にアルゴリズムを知りたいという方は読み飛ばしても良いと思います。


文字列 $x$ から $y$ へ書き換える時、レーベンシュタイン距離を $D(x,y)$ と表しましょう。
文字列の部分文字列を考える時、$x[...i]$ は 文字列 $x$ の$1$番目から$i$番目までの部分文字列、$x[i]$は$i$番目の文字を与えるとしましょう。ただし $x[0]$ は長さ0の文字を表すこととします。そして$D(x[0],y[0]) = 0$と規約しても不都合はないと考えられます。

**定理**

*$D(x[...i],y[...j])$ は次の値の内の最小値に一致する：*
- $D(x[...(i-1)],y[...j]) + 1$
- $D(x[...i],y[...(j-1)]) + 1$
- $D(x[...(i-1)],y[...(j-1)]) + t(x[i],y[j])$

*ただし、$t(a,b)$ は文字 $a, b$ が一致する時に $0$ 、そうでない時に $1$ を与えます。*

**例**

先の例 $x="bnb", y="anana"$ を考えましょう。

次の文字列の組の図式を考えます：

$$
\begin{array}{ccccc}
 (x[0],y[0]) & \to & (x[0],y[...1]) & \to & (x[0],y[...2]) \\
 \downarrow & & \downarrow & & \downarrow \\
 (x[...1],y[0]) & \to & (x[...1],y[...1]) & \to & (x[...1],y[...2]) \\
 \downarrow & & \downarrow & & \downarrow \\
(x[...2],y[0]) & \to & (x[...2],y[...1]) & \to & (x[...2],y[...2]) \\
\end{array}
$$

右へ遷移すると部分文字列 $y[...j]$ のインデックス $j$ が増加し、下へ遷移すると部分文字列 $x[...i]$ のインデックス $i$ が増加します。

今回の例に沿って具体的に見ていきましょう：

$$
\begin{array}{ccccc}
 ("","") & \to & ("","a") & \to & ("","an") \\
 \downarrow & & \downarrow & & \downarrow \\
 ("b","") & \to & ("b","a") & \to & ("b","an") \\
 \downarrow & & \downarrow & & \downarrow \\
("bn","") & \to & ("bn","a") & \to & ("bn","an") \\
\end{array}
$$

まず $("b","an")$ のレーベンシュタイン距離 $D("b","an")$ を考えます。
計算のアルゴリズムを考えるため、愚直に考えるより図式のステップを考えていったほうがアルゴリズムを見つけやすいと思います。

最初に直上の前ステップ $("","an")$ を使ってレーベンシュタイン距離を求めることはできないか考えましょう。この場合、文字列 $"b"$ を一旦削除すれば帰着できることが分かります。つまり $D("b","an") \leq D("","an") + \#\{ D \} = D("","an") + 1$ を得ることができます。ここで不等号が成り立つことはレーベンシュタイン距離が最小の手数を考えることに由来します。（この場合、一旦削除することは最小の手数を与えないように思えます。）

次に左のステップ $("b","a")$ を考えましょう。これは $"a"$に挿入を行い$"an"$を得る操作を加えれば良いと思われます。つまり $D("b","an") \leq D("b","a") + \#\{ I \} = D("b","a") + 1$ を得ます。

最後に対角線上のステップ $("","a")$ を考えます。これは $"b"$ を一旦削除し $D("","a")$ の操作の経路を経て $"a"$ に $"n"$ を挿入すれば、$"b"$ から $"an"$ を得ます。ここで一旦 $"b"$ を削除し $"n"$ を挿入することは操作の最初に $"b"$ を $"n"$ へ置換することと同等です。よって $D("b","an") \leq D("","a") + \#\{ R\} = D("","a") + 1$ を得ます。

今までの帰着の方法において前ステップの操作の前後に新たな操作を加えることを考えました。
任意の操作の経路は前ステップのどれかの操作の経路を通らなければならないでしょう。実際、 $"b"$ から $"an"$ を得るにあたって、$"b"$ を削除するのであれば直上のステップ $("","an")$ の操作の経路を経るし、そうしないのであれば最後の操作として $"a"$ に文字を挿入する（ $("b","a")$ ）か $"b"$ を置換する（$("","a")$）はずです。
そして最短の経路の部分経路は最短であるべきです。

よって $D("b","an")$ は $D("","an") + 1$、$D("b","a") + 1$ もしくは $D("","a") + 1$ と一致しなければなりません。
ただし、対角線上のステップからレーベンシュタイン距離を得る場合は置換が加わらないことがあります。実際、$D("bn","an") = D("b","a")$ です。

**証明**
省略します。



## 計算アルゴリズム

## プログラム
